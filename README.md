# CS-MEDIUM-02 定点数精确运算
## **任务1**
1. 为什么会出现这样的现象？请阅读相关资料后提交与于arkdown文档。
    >首先，浮点型的存储是分为指数位和小数位的，结果是小数位乘上2的幂。
    因为采取的是二进制，而十是二的倍数，所以所有的***有限的二进制数***都可以转换为与之对应的***准确***的十进制数。
    但是不是所有***有限的十进制数***都能用***准确的***二进制数表示，就比如0.1D，就不能精确地用二进制表示。
    这时，表示的精度就取决于小数位数的多少了。在这一过程中还伴随着舍入，舍入采取的是向偶数舍入。

2. 该如何获得精确值呢？请阅读相关资料后提交于markdown文档。
    >因为二进制都可以用十进制精确表示，所以要真正意义上得到绝对精确的结果只需要将所有的二进制转换为十进制，
    但是二进制小数部分是要进行移位操作来进行单独存储的。
    首先要明白***二进制小数位数是与十进制小数位数相同的***，
    比如0.1B=0.5D,0.01B=0.25D.利用移位原理将小数部分视作整数部分进行处理得到一个中间数N，
    然后进行`decimal=N/2^*10^`。其中^是小数位数,*10^是为了让其继续为整数。化简后就为    `decimal=N*5^`。就比如0.11B,`N=3,^=2,decimal=75`。接下来就只需要采取大数计算即可。

## 任务2

1. 怎么才能让我们定义的结构体占据最小的内存？
    >因为结构体以及C语言中的其他变量都有**对齐**原则，
    而且结构体的变量地址也是随着声明顺序进行的，
    所以在结构体中的变量最好采取***空间从大到小***的声明。这样就能尽可能地省略对齐。

2. 乘法的本质是什么？减法的本质又是什么呢？
    >乘法的本质是一堆加法，减法的本质是加上一个相反数。
3. 该如何判断溢出呢？或许该有个特殊的计数器？
    >如果出现了溢出，那么结果就会是原结果进行取余运算得到的结果。
    一般正数加上正数如果出现了溢出就会得到负数，判断为`“a+b”=a+b-Max`.
    相反的负数加负数如果溢出就会得到正数,判断为`"a+b"=a+b+Max`。
    乘法的溢出反正也不会得到想要的结果就是了。把乘法拆成加法进行判断即可。    
4. 从计算机中的逻辑运算角度出发，减法如何转化为加法？
    >如果是采取补码的计算的话，负数a本来就被表示为Max-a,也就是最高位向量为1，因为max相当于0（跟溢出时一样），这样的话，直接相加就行。

prepare:
    ![prepare](test5/prepare.png)

task2:
    ![task2_1](test5/task2_1.png) 
task3:
    ![task3](test5/task3.png)      
